"""Deterministic lockfile for skill versioning (asm.lock).

Provides reproducible skill installations across team members.
Analogous to package-lock.json but for agent skills.
"""

from __future__ import annotations

import hashlib
from datetime import datetime, timezone
from pathlib import Path

import tomlkit

from asm import __version__
from asm.core.models import LockEntry


def compute_integrity(skill_dir: Path) -> str:
    """SHA-256 over sorted file paths + contents for deterministic hashing."""
    hasher = hashlib.sha256()
    for path in sorted(skill_dir.rglob("*")):
        if path.is_file():
            hasher.update(path.relative_to(skill_dir).as_posix().encode())
            hasher.update(path.read_bytes())
    return f"sha256:{hasher.hexdigest()}"


def dump(entries: dict[str, LockEntry]) -> str:
    """Serialize lock entries to TOML."""
    doc = tomlkit.document()
    doc.add(tomlkit.comment("Auto-generated by ASM â€” do not edit manually"))
    doc.add(tomlkit.nl())

    meta = tomlkit.table()
    meta.add("generated_at", datetime.now(timezone.utc).isoformat())
    meta.add("asm_version", __version__)
    doc.add("metadata", meta)

    skills_super = tomlkit.table(is_super_table=True)
    for name, entry in sorted(entries.items()):
        tbl = tomlkit.table()
        tbl.add("version", entry.version)
        tbl.add("registry", entry.registry)
        tbl.add("integrity", entry.integrity)
        if entry.resolved:
            tbl.add("resolved", entry.resolved)
        if entry.commit:
            tbl.add("commit", entry.commit)
        skills_super.add(name, tbl)
    doc.add("skills", skills_super)

    return tomlkit.dumps(doc)


def load(path: Path) -> dict[str, LockEntry]:
    """Deserialize asm.lock into LockEntry dict."""
    if not path.exists():
        return {}
    raw = tomlkit.loads(path.read_text())
    skills_raw = raw.get("skills", {})

    entries: dict[str, LockEntry] = {}
    for name, meta in skills_raw.items():
        entries[name] = LockEntry(
            name=name,
            version=meta.get("version", "0.0.0"),
            registry=meta.get("registry", ""),
            integrity=meta.get("integrity", ""),
            resolved=meta.get("resolved", ""),
            commit=meta.get("commit", ""),
        )
    return entries


def save(entries: dict[str, LockEntry], path: Path) -> None:
    """Write lockfile to disk."""
    path.write_text(dump(entries))


def verify(skill_dir: Path, expected: str) -> bool:
    """Check if installed skill matches its locked integrity hash."""
    return compute_integrity(skill_dir) == expected
