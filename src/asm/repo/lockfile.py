"""Deterministic lockfile for skill versioning (asm.lock).

Provides reproducible skill installations across team members.
Analogous to package-lock.json but for agent skills.
"""

from __future__ import annotations

import hashlib
from datetime import datetime, timezone
from pathlib import Path

import tomlkit

from asm import __version__
from asm.core.models import LockEntry

LOCK_FORMAT_VERSION = 2
DEFAULT_REGISTRY_ID = "default"


def compute_integrity(skill_dir: Path) -> str:
    """SHA-256 over sorted file paths + contents for deterministic hashing."""
    hasher = hashlib.sha256()
    for path in sorted(skill_dir.rglob("*")):
        if path.is_file():
            hasher.update(path.relative_to(skill_dir).as_posix().encode())
            hasher.update(path.read_bytes())
    return f"sha256:{hasher.hexdigest()}"


def _now_utc() -> str:
    return datetime.now(timezone.utc).isoformat()


def dump(entries: dict[str, LockEntry], *, registry_id: str = DEFAULT_REGISTRY_ID) -> str:
    """Serialize lock entries to TOML."""
    doc = tomlkit.document()
    doc.add(tomlkit.comment("Auto-generated by ASM â€” do not edit manually"))
    doc.add(tomlkit.nl())

    meta = tomlkit.table()
    meta.add("generated_at", _now_utc())
    meta.add("asm_version", __version__)
    meta.add("lock_format", LOCK_FORMAT_VERSION)
    meta.add("registry_id", registry_id)
    doc.add("metadata", meta)

    skills_super = tomlkit.table(is_super_table=True)
    for name, entry in sorted(entries.items()):
        tbl = tomlkit.table()
        tbl.add("upstream_version", entry.upstream_version)
        tbl.add("local_revision", entry.local_revision)
        tbl.add("registry", entry.registry)
        tbl.add("integrity", entry.integrity)
        if entry.snapshot_id:
            tbl.add("snapshot_id", entry.snapshot_id)
        if entry.parent_snapshot_id:
            tbl.add("parent_snapshot_id", entry.parent_snapshot_id)
        if entry.resolved:
            tbl.add("resolved", entry.resolved)
        if entry.commit:
            tbl.add("commit", entry.commit)
        skills_super.add(name, tbl)
    doc.add("skills", skills_super)

    return tomlkit.dumps(doc)


def load(path: Path) -> dict[str, LockEntry]:
    """Deserialize asm.lock into LockEntry dict."""
    if not path.exists():
        return {}
    raw = tomlkit.loads(path.read_text())
    skills_raw = raw.get("skills", {})

    entries: dict[str, LockEntry] = {}
    for name, meta in skills_raw.items():
        # Backward compatibility: v1 lockfile used `version`.
        upstream_version = meta.get("upstream_version", meta.get("version", "0.0.0"))
        entries[name] = LockEntry(
            upstream_version=upstream_version,
            local_revision=int(meta.get("local_revision", 0)),
            registry=meta.get("registry", ""),
            integrity=meta.get("integrity", ""),
            resolved=meta.get("resolved", ""),
            snapshot_id=meta.get("snapshot_id", ""),
            parent_snapshot_id=meta.get("parent_snapshot_id", ""),
            commit=meta.get("commit", ""),
        )
    return entries


def save(entries: dict[str, LockEntry], path: Path, *, registry_id: str = DEFAULT_REGISTRY_ID) -> None:
    """Write lockfile to disk."""
    path.write_text(dump(entries, registry_id=registry_id))


def migrate(path: Path, *, registry_id: str = DEFAULT_REGISTRY_ID) -> bool:
    """Upgrade older lockfile schemas in-place. Returns True when migrated."""
    if not path.exists():
        return False
    raw = tomlkit.loads(path.read_text())
    metadata = raw.get("metadata", {})
    current_fmt = int(metadata.get("lock_format", 1))
    if current_fmt >= LOCK_FORMAT_VERSION:
        return False
    entries = load(path)
    save(entries, path, registry_id=registry_id)
    return True


def verify(skill_dir: Path, expected: str) -> bool:
    """Check if installed skill matches its locked integrity hash."""
    return compute_integrity(skill_dir) == expected
